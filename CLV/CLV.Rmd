---
title: "Deligreens Customer Lifetime Value"
# author: "Arnaud Lafont"
date: "5 juin 2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
library(ggplot2)
library(plyr) # Ne pas changer l'ordre de chargement : plyr puis dplyr
library(dplyr) # Ne pas changer l'ordre de chargement : plyr puis dplyr
library(BTYD)
library(survival)
library(survminer)
library(knitr)
library(reshape2)

# Liste des équipiers
email_equipier <- c('dumontet.thibaut@gmail.com', 'dumontet.julie@gmail.com', 'laura.h.jalbert@gmail.com', 'rehmvincent@gmail.com', 'a.mechkar@gmail.com', 'helena.luber@gmail.com', 'martin.plancquaert@gmail.com', 'badieresoscar@gmail.com', 'steffina.tagoreraj@gmail.com', 'perono.jeremy@gmail.com', 'roger.virgil@gmail.com', 'boutiermorgane@gmail.com', 'idabmat@gmail.com', 'nadinelhubert@gmail.com', 'faure.remi@yahoo.fr', 'maxime.cisilin@gmail.com', 'voto.arthur@gmail.com', 'pedro7569@gmail.com')

source("../Fonctions_Core_DB.R")
source("~/Documents/Linfo_core.R")

# Informations de connexion à la DB Core
dbname <- Sys.getenv("dbname")
dbhost <- Sys.getenv("dbhost")
dbuser <- Sys.getenv("dbuser")
dbpass <- Sys.getenv("dbpass")

rouge <-"#EC7963"
bleu <- "#584E7C"
vert <- "#77D7D2"

# Récupération des commandes CORE
req <- "SELECT  o.order_number,
                o.shopify_id,
              	o.client_id,
                c.email,
                c.created_at AS client_created_at,
                c.orders_count,
              	o.created_at AS order_created_at,
              	SUM(CEILING(li.quantity * li.selling_price_cents/(1+tax_rate))) AS gross_sale,
                o.total_shipping_cents/1.2 AS shipping_ht,
                o.financial_status,
                c.first_order_date
  FROM orders o, line_items li, clients c
  WHERE o.id = li.order_id AND o.client_id = c.id
  GROUP BY  o.order_number,
            o.shopify_id,
          	o.client_id,
            c.email,
            c.created_at,
            c.orders_count,
          	o.created_at,
            o.total_shipping_cents/1.2,
            o.financial_status,
            c.first_order_date
  ORDER BY  order_created_at"
commandes1 <- extract_core(req, dbname, dbhost, dbuser, dbpass) %>%
  mutate(client_id = as.character(client_id),
         gross_sale = gross_sale/100,
         shipping_ht = shipping_ht/100,
         gross_revenue = gross_sale + shipping_ht) %>%
  select(order_number, client_id, email, gross_revenue, client_created_at, first_order_date, order_created_at, financial_status)

# Vieilles commandes
commandes2 <- read.csv("../old_commandes_shopify.csv", sep = ";", header = T, dec = ",") %>%
  filter(!(order_number %in% commandes1$order_number)) %>%
  mutate(order_created_at = as.POSIXct(order_created_at),
         first_order_date = as.POSIXct(first_order_date),
         email = as.character(email),
         financial_status = as.character(financial_status)) %>%
  group_by(email) %>%
  mutate(client_created_at = min(order_created_at)) %>%
  ungroup()

# Un client a changé d'adresse email, on remplace l'ancienne par la nouvelle dans toutes les commandes
commandes2$email[commandes2$email == "amigafeeling@free.fr"] <- "ludovic.chirol@orange.fr"
commandes2$email[commandes2$email == "quentinrigo@gmail.com"] <- "blondinettedu71@gmail.com"


# On trouve le client_id des clients qui en ont un (ceux qui ont une commande dans core)
email_id <- commandes1 %>%
  group_by(client_id) %>% summarise(email = first(email))
commandes2 <- left_join(commandes2, email_id, by = "email") %>%
  # Pour ceux qui n'en ont pas on utilise l'email
  mutate(client_id = ifelse(is.na(client_id), email, client_id))

# Fusion des df
commandes <- rbind(commandes1, commandes2)

# Dans Core, les montants des commandes 8556 à 8620 sont mauvaises donc les récupère depuis un export de Shopify
commandes3 <- read.csv("../corr_commandes_shopify.csv", sep = ";", header = T, dec = ",")
for(c in 8556:8620){
  commandes$gross_revenue[commandes$order_number == c] <- commandes3$gross_revenue[commandes3$order_number == c]
}

# Reformatage des POSIX, on ne garde que les dates, les heures ne sont pas utiles
commandes <- commandes %>%
  mutate(client_created_at = as.Date(client_created_at),
         first_order_date = as.Date(first_order_date),
         order_created_at = as.Date(order_created_at))

# On retire les commandes des coéquipiers
commandes <- commandes %>%
  filter(!(email %in% email_equipier) & !(grepl("@deligreens.com$",email)))

# On retire les commandes "refunded" ou "voided"
commandes <- commandes %>%
  filter(!(financial_status %in% c("refunded", "voided"))) %>%
  select(-financial_status)

# Si un client passe plusieurs commandes le même jour on les fusionne
commandes <- commandes %>%
  group_by(client_id, email, client_created_at, first_order_date, order_created_at) %>%
  summarise(order_number = first(order_number),
            fusionne = n()>1,
            gross_revenue = sum(gross_revenue)) %>%
  ungroup()

# On retire ces commandes qui ne comportent que des cartes cadeaux
commandes <- commandes %>%
  filter(!(order_number %in% c(7084,10201,10461,10606,11693)))

# Si on a une commande antérieure à la date de première commande on corrige la date de première commande
commandes <- commandes %>%
  group_by(client_id) %>%
  mutate(first_order_date = min(order_created_at)) %>%
  ungroup()

# nieme et orders_count
commandes <- commandes %>%
  arrange(client_id, order_created_at) %>%
  group_by(client_id) %>%
  mutate(nieme = row_number(),
         orders_count = max(nieme)) %>%
  ungroup()

# Pour la colonne nieme_classe
breaks_class_cli <- c(1, 2, 6, Inf)
labels_class_cli <- c("1ère", "2-5ème", "6+")

# # Pour la colonne age_classe
# breaks_age <- c(0:6, 9, 13, 19)

# Création de colonnes
commandes <- commandes %>%
  arrange(client_id, desc(order_created_at)) %>%
  # calcul du délai entre une commande et la précédente d'un client
  mutate(delai = ifelse(client_id == lag(client_id), round(difftime(lag(order_created_at), order_created_at, units = "days")), NA))%>%
  # nieme = la commande est la combientième du client
  group_by(client_id) %>%
  mutate(#nieme = orders_count - row_number() + 1,
         nieme_class = cut(nieme,
                           breaks = breaks_class_cli,
                           labels = labels_class_cli,
                           right = F,
                           include.lowest = T)) %>%
  # derniere : la commande est-elle la dernière du client
  mutate(derniere = order_created_at == max(order_created_at)) %>%
  ungroup() %>%
  # pas_revu_depuis : Combien de temps s'est-il écoulé depuis que le client n'a pas commandé
  mutate(pas_revu_depuis = ifelse(derniere, round(difftime(now(),order_created_at, units="days")),NA)) %>%
  # Création des colonnes semaine et mois
  mutate(semaine = floor_date(order_created_at, unit = "week", week_start = getOption("lubridate.week.start", 1)),
         mois = floor_date(order_created_at, unit = "month")) %>%
  # Ajout de le cohorte et de l'age lors de la commande
  mutate(cohorte_temp = floor_date(first_order_date, unit = "month"),
         # création de la cohorte, de classe character, qu'on va plus tard convertir en factor
         cohorte = format(cohorte_temp, "%B %y"),
         age_jour = as.numeric(difftime(order_created_at, first_order_date, units = "days")),
         # age_exact = age_jour/30,
         age = floor(age_jour/30))

# ordered levels du factor cohorte
levels <- commandes$cohorte_temp %>%
  unique() %>%
  sort()

commandes <- commandes %>%
  mutate(cohorte = factor(cohorte, levels = format(levels, "%B %y"))) %>%
  select(-cohorte_temp)
```


<!-- ```{r setup, include=FALSE} -->
<!-- # !diagnostics off -->
<!-- knitr::opts_chunk$set(echo = TRUE) -->

<!-- library(ggplot2) -->
<!-- library(plyr) # Ne pas changer l'ordre de chargement : plyr puis dplyr -->
<!-- library(dplyr) # Ne pas changer l'ordre de chargement : plyr puis dplyr -->
<!-- library(BTYD) -->
<!-- library(survival) -->
<!-- library(survminer) -->

<!-- source("../Fonctions_Core_DB.R") -->
<!-- source("~/Documents/Linfo_core.R") -->

<!-- # Informations de connexion à la DB Core -->
<!-- dbname <- Sys.getenv("dbname") -->
<!-- dbhost <- Sys.getenv("dbhost") -->
<!-- dbuser <- Sys.getenv("dbuser") -->
<!-- dbpass <- Sys.getenv("dbpass") -->

<!-- # Chartre graphique -->
<!-- rouge <-"#EC7963" -->
<!-- bleu <- "#584E7C" -->
<!-- vert <- "#77D7D2" -->

<!-- # Liste des équipiers -->
<!-- email_equipier <- c('dumontet.thibaut@gmail.com', 'dumontet.julie@gmail.com', 'laura.h.jalbert@gmail.com', 'rehmvincent@gmail.com', 'a.mechkar@gmail.com', 'helena.luber@gmail.com', 'martin.plancquaert@gmail.com', 'badieresoscar@gmail.com', 'steffina.tagoreraj@gmail.com', 'perono.jeremy@gmail.com', 'roger.virgil@gmail.com', 'boutiermorgane@gmail.com', 'idabmat@gmail.com', 'nadinelhubert@gmail.com', 'faure.remi@yahoo.fr', 'maxime.cisilin@gmail.com', 'voto.arthur@gmail.com', 'pedro7569@gmail.com') -->

<!-- # Récupération des commandes -->
<!-- req <- "SELECT  o.order_number, -->
<!--               	o.client_id, -->
<!--                 c.email, -->
<!--                 c.created_at AS client_created_at, -->
<!--                 c.orders_count, -->
<!--               	o.created_at AS order_created_at, -->
<!--               	SUM(CEILING(li.quantity * li.selling_price_cents/(1+tax_rate))) AS gross_sale, -->
<!--                 o.total_shipping_cents/1.2 AS shipping_ht, -->
<!--                 o.financial_status, -->
<!--                 c.first_order_date -->
<!--   FROM orders o, line_items li, clients c -->
<!--   WHERE o.id = li.order_id AND o.client_id = c.id -->
<!--   GROUP BY  o.order_number, -->
<!--           	o.client_id, -->
<!--             c.email, -->
<!--             c.created_at, -->
<!--             c.orders_count, -->
<!--           	o.created_at, -->
<!--             o.total_shipping_cents/1.2, -->
<!--             o.financial_status, -->
<!--             c.first_order_date -->
<!--   ORDER BY  order_created_at" -->
<!-- commandes <- extract_core(req, dbname, dbhost, dbuser, dbpass) -->

<!-- # Corrections manuelles : -->
<!-- # Client_id avec des commandes remboursées complètement : comptées dans orders_number mais inexistantes dans la bd Core -->
<!-- commandes$orders_count[commandes$client_id == 2478] <- commandes$orders_count[commandes$client_id == 2478] -1 -->
<!-- commandes$orders_count[commandes$client_id == 2575] <- commandes$orders_count[commandes$client_id == 2575] -1 -->
<!-- # Client_id avec des first_order_date erronées -->
<!-- commandes$first_order_date[commandes$client_id == 4050] <- as.POSIXct("2018-06-03 00:00:01") -->
<!-- commandes$first_order_date[commandes$client_id == 4199] <- as.POSIXct("2018-06-20 00:00:01") -->
<!-- # Montants erronés -->
<!-- commandes$total_price[commandes$order_number == 7574] = commandes$gross_sale[commandes$order_number == 7574] = 12732 -->
<!-- commandes <- commandes %>% -->
<!--   # On retire le client 2495 qui ne commande que des cartes cadeaux -->
<!--   filter(client_id != 2495) %>% -->
<!--   group_by(client_id) %>% -->
<!--   # Si un client a été créé après le 30 avril 2017 et qu'il n'a pas de date de premiere commande on la trouve -->
<!--   mutate(first_order_date = as.POSIXct(ifelse(is.na(first_order_date) & client_created_at > as.Date("2017-04-30"), min(order_created_at),first_order_date), origin = "1970-01-01")) %>% -->
<!--   ungroup() -->
<!--   # On retire les commandes avec des ventes = 0 € car se sont soit des annulations soit des erreurs dans la BD -->
<!--     # D'abord on corrige le orders_count -->
<!--   temp <- commandes %>% -->
<!--     filter(gross_sale <= 0) %>% -->
<!--     group_by(client_id) %>% -->
<!--     summarise(nb_a_0 = n()) -->
<!--   commandes <- left_join(commandes, temp, by = "client_id") %>% -->
<!--     mutate(orders_count = ifelse(is.na(nb_a_0), orders_count, orders_count - nb_a_0)) %>% -->
<!--     select(-nb_a_0) -->
<!--   rm(temp) -->
<!--     # Puis on enlève ces commandes -->
<!-- commandes <- commandes %>% -->
<!--   filter(gross_sale > 0) -->
<!-- # Orders_count erroné -->
<!-- # liste des clients pour lesquels ont a plus de commandes dans le df que leur orders_count -->
<!-- commandes <- commandes %>% -->
<!--   group_by(client_id) %>% -->
<!--   mutate(diff = n() - first(orders_count)) %>% -->
<!--   ungroup() %>% -->
<!--   mutate(orders_count = ifelse(diff > 0, orders_count + diff, orders_count)) %>% -->
<!--   select(-diff) -->

<!-- # Mise en forme -->
<!-- commandes <- commandes %>% -->
<!--   # La date du jour nous suffit, pas besoin de l'heure -->
<!--   mutate(client_created_at = as.Date(client_created_at), -->
<!--          order_created_at = as.Date(order_created_at), -->
<!--          first_order_date = as.Date(first_order_date)) %>% -->
<!--   # Conversion des centimes en euros -->
<!--   mutate(gross_sale = gross_sale/100, -->
<!--          # total_price = total_price/100, -->
<!--          shipping_ht = shipping_ht/100) -->

<!-- # Si un client a passé 2 commandes le même jour, on les regroupe -->
<!-- commandes <- commandes %>% -->
<!--   group_by(client_id, email, orders_count, client_created_at, first_order_date, order_created_at) %>% -->
<!--   summarise(#total_price = sum(total_price), -->
<!--             gross_sale = sum(gross_sale), -->
<!--             shipping_ht = sum(shipping_ht), -->
<!--             nb_a_corr = n()-1) %>% -->
<!--   ungroup() -->
<!-- # Et on réduit orders_count en conséquence -->
<!-- temp <- commandes %>% -->
<!--   group_by(client_id) %>% -->
<!--   summarise(correction = sum(nb_a_corr)) %>% -->
<!--   ungroup() -->
<!-- commandes <- left_join(commandes, temp, by = "client_id") %>% -->
<!--   mutate(orders_count = orders_count - correction) %>% -->
<!--   select(-nb_a_corr, -correction) -->
<!-- rm(temp) -->

<!-- # Pour la colonne nieme_classe -->
<!-- breaks_class_cli <- c(1, 2, 6, Inf) -->
<!-- labels_class_cli <- c("1ère", "2-5ème", "6+") -->
<!-- # breaks_class_cli <- c(1, 2, 3, Inf) -->
<!-- # labels_class_cli <- c("1ère", "2-3ème", "4+") -->

<!-- # Création de colonnes -->
<!-- commandes <- commandes %>% -->
<!--   arrange(client_id, desc(order_created_at)) %>% -->
<!--   # calcul du délai entre une commande et la précédente d'un client -->
<!--   mutate(delai = ifelse(client_id == lag(client_id), round(difftime(lag(order_created_at), order_created_at, units = "days")), NA))%>% -->
<!--   # nieme = la commande est la combientième du client -->
<!--   group_by(client_id) %>% -->
<!--   mutate(nieme = orders_count - row_number() + 1, -->
<!--          nieme_class = cut(nieme, -->
<!--                            breaks = breaks_class_cli, -->
<!--                            labels = labels_class_cli, -->
<!--                            right = F, -->
<!--                            include.lowest = T)) %>% -->
<!--   # derniere : la commande est-elle la dernière du client -->
<!--   mutate(derniere = order_created_at == max(order_created_at)) %>% -->
<!--   ungroup() %>% -->
<!--   # pas_revu_depuis : Combien de temps s'est-il écoulé depuis que le client n'a pas commandé -->
<!--   mutate(pas_revu_depuis = ifelse(derniere, round(difftime(now(),order_created_at, units="days")),NA)) %>% -->
<!--   # Création des colonnes semaine et mois -->
<!--   mutate(semaine = floor_date(order_created_at, unit = "week", week_start = getOption("lubridate.week.start", 1)), -->
<!--          mois = floor_date(order_created_at, unit = "month")) %>% -->
<!--   # Ajout de le cohorte et de l'age lors de la commande -->
<!--   mutate(cohorte = floor_date(first_order_date, unit = "month"), -->
<!--          age_jour = as.numeric(difftime(order_created_at, first_order_date, units = "days")), -->
<!--          age = floor(age_jour/30)) %>% -->
<!--   # Ajout des frais de livraison dans les ventes totales -->
<!--   mutate(gross_revenue = gross_sale + shipping_ht) %>% -->
<!--   select(-shipping_ht) -->

<!-- # Filtres -->
<!-- commandes <- commandes %>% -->
<!--   # On ne garde que les commandes des clients qui ne sont pas des équipiers -->
<!--   filter(!(email %in% email_equipier) & !(grepl("@deligreens.com$",email))) %>% -->
<!--   # On ne garde que les données postérieures au 1er mai 2017 -->
<!--   filter(order_created_at >= as.Date("2017-05-01")) -->

<!-- # Vieilles commandes -->
<!-- # commandes2 <- read.csv("../old_commandes_shopify.csv", sep = ";", header = T) -->

<!-- ``` -->

### Customer Value sur 6 mois

```{r, echo=FALSE, warning=FALSE}
# Echantillon de clients : première commande passée entre DEBUT et FIN
debut <- as.Date("2017-09-01")
fin <- as.Date("2017-10-31")

# durée d'observation (en jours)
duree <- 180
```

Dans cette partie, pour cadrer l'étude, nous allons nous baser sur les clients qui ont passé leurs premières commandes entre le `r debut` et le `r fin`<br>
Chaque client va être étudié sur les 6 mois qui suivent sa première commande afin d'avoir une période d'observation égale.

```{r echantillonage, echo=FALSE, warning=FALSE}
com <- commandes %>%
  # On ne garde que les clients qui ont passé leur première commande dans la periode choisie
  filter(first_order_date >= debut & first_order_date <= fin) %>%
  # On ne garde que les commandes qu'ils ont passé dans la durée choisie
  filter(age_jour < duree)

nb_com <- nrow(com)
```

```{r rang de la commande, echo=FALSE, warning=FALSE}
com <- com %>%
  # Calcul du rang de la commande
  arrange(client_id, order_created_at)# %>%
  # group_by(client_id) %>%
  # mutate(nieme = row_number()) %>%
  # ungroup()

nb_cli <- n_distinct(com$client_id)
```

Nous avons donc `r nb_cli` clients qui ont passé `r nb_com` commandes en `r duree` jours.

```{r gross_revenue_ht, echo=FALSE, warning=FALSE}
gross_revenue_tot <- sum(com$gross_revenue)
gross_revenue_cli <- gross_revenue_tot/nb_cli
```

Cela représente `r format(gross_revenue_tot, big.mark = " ", scientific = F)` € de vente brute HT, soit une moyenne de `r round(gross_revenue_cli,2)` € par client.

##### La customer value moyenne à 6 mois de nos clients est donc `r round(gross_revenue_cli,2)` €

Explorons le comportement des clients pendant ces 6 mois.

```{r repurchase rate, echo=FALSE, warning=FALSE}
df <- com %>%
  filter(nieme == 2) %>%
  group_by(client_id) %>%
  summarise(reorder_age = min(age_jour)) %>%
  ungroup() %>%
  mutate(inf_30 = reorder_age <= 30,
         inf_60 = reorder_age <= 60,
         inf_90 = reorder_age <= 90,
         inf_180 = reorder_age <= 180) %>%
  summarise(inf_30 = sum(inf_30)/nb_cli,
            inf_60 = sum(inf_60)/nb_cli,
            inf_90 = sum(inf_90)/nb_cli,
            inf_180 = sum(inf_180)/nb_cli)

df <- data.frame(x = colnames(df),
                 y = as.numeric(df[1,])) %>%
  mutate(x = factor(x, levels = c("inf_30", "inf_60", "inf_90", "inf_180")))

labels <- paste(round(100*df$y,1),"%")

ggplot(data = df, aes(x = x)) +
  geom_bar(stat = "identity", aes(y = y), fill = rouge) +
  geom_text(aes(y = y, label = labels), vjust = 1.5, color = "white") +
  geom_hline(yintercept = 0) +
  theme_classic() +
  scale_y_continuous(breaks = seq(0,1,0.2), labels = paste(100*seq(0,1,0.2),"%"), limits = c(0,1)) +
  scale_x_discrete(labels = c("à 30 jours", "à 60 jours", "à 90 jours", "à 180 jours")) +
  labs(title = "Repurchase rate", x = NULL, y = "Pourcentage des clients qui repassent commande") +
  theme(panel.grid.major.y = element_line(color = "gray", size = 0.1),
        panel.grid.minor.y = element_line(color = "gray", size = 0.1, linetype = "dashed"),
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

`r labels[4]` des `r nb_cli` clients ont repassé une (ou plusieurs) commande dans les 180 jours qui ont suivis leurs premières commandes.

```{r graph rétention clients, echo=FALSE, warning=FALSE}
df <- com %>%
  group_by(age) %>%
  summarise(nb_cli = n_distinct(client_id),
            moy_com = n()/nb_cli,
            ventes_moy = sum(gross_revenue/nb_cli)) %>%
  ungroup()

facteur <- 1

lm <- lm(ventes_moy~age, data = df)

ggplot(data = df, aes(x = age)) +
  geom_hline(yintercept = 0) +
  geom_bar(aes(y = nb_cli), stat = "identity", fill = rouge) +
  geom_text(aes(y = nb_cli, label = nb_cli), color = "white", vjust = 1.5) +
  # geom_point(aes(y = ventes_moy), color = vert) +
  # geom_abline(intercept = lm$coefficients[1]*facteur, slope = lm$coefficients[2]*facteur, color = vert) +
  scale_x_continuous(breaks = df$age, name = "Ancienneté des clients en mois") +
  scale_y_continuous(breaks = seq(0,500,50), name = "Nombre de clients") +
  scale_color_manual(values = rouge) +
  labs(shape = NULL, colour = NULL, title = "Rétention clients", subtitle = "") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(color = "gray", size = 0.1),
        panel.grid.minor.y = element_line(color = "gray", size = 0.1, linetype = "dashed"),
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

Rétention des client sur 6 mois : 
`r df$nb_cli[df$age == 5]`/`r df$nb_cli[df$age == 0]` = `r round(100*df$nb_cli[df$age == 5]/df$nb_cli[df$age == 0],1)` %

```{r graph retention commandes, echo=FALSE, warning=FALSE}
df <- com %>%
  group_by(age) %>%
  summarise(nb_com = n(),
            panier_moyen = mean(gross_revenue)) %>%
  ungroup()

# droite de regression
lm <- lm(panier_moyen~age, data = df)

# facteur pour le 2ème axe
facteur <- 5

ggplot(data = df, aes(x = age)) +
  geom_hline(yintercept = 0) +
  geom_bar(aes(y = nb_com, color = "Nb commandes"), stat = "identity", fill = bleu) +
  geom_text(aes(y = nb_com, label = nb_com), color = "white", vjust = 1.5) +
  geom_point(aes(y = panier_moyen*facteur, shape = "Panier moyen"), color = vert) +
  geom_abline(intercept = lm$coefficients[1]*facteur, slope = lm$coefficients[2]*facteur, color = vert) +
  scale_x_continuous(breaks = df$age, name = "Ancienneté des clients en mois") +
  scale_y_continuous(breaks = seq(0,500,50), name = "Nombre de commandes",
                     sec.axis =  sec_axis(trans = ~./facteur, name = "Panier moyen", breaks = seq(0,500,50)/facteur, labels = paste(seq(0,500,50)/facteur,"€"))) +
  scale_color_manual(values = bleu) +
  labs(shape = NULL, colour = NULL, title = "Evolution du nombre de commandes et du panier moyen") +
  theme_classic() +
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_line(color = "gray", size = 0.1),
        panel.grid.minor.y = element_line(color = "gray", size = 0.1, linetype = "dashed"),
        plot.title = element_text(hjust = 0.5),
        legend.position = "top")
```

Après une chute inévitable du nombre de commandes sur les premiers mois, on peut voir qu'il se stabilise dès le 3ème mois.
Il est aussi intéressant de noter que le panier moyen des commandes (i.e. les ventes brutes) augmente au fil du temps, passant de `r round(df$panier_moyen[df$age == 0],2)`€ à `r round(df$panier_moyen[df$age == 5],2)`€ sur 6 mois.

Rétention en terme de commandes :
`r df$nb_com[df$age == 5]` / `r df$nb_com[df$age == 0]` = `r round(100*df$nb_com[df$age == 5]/df$nb_com[df$age == 0],1)`%


```{r graph retention ventes, echo=FALSE, warning=FALSE}
df <- com %>%
  group_by(age) %>%
  summarise(ca = sum(gross_revenue))

ggplot(df) +
  geom_bar(stat = "identity", aes(x = age, y = ca), fill = vert) +
  geom_text(aes(x = age, y = ca, label = paste(format(round(ca), big.mark =" "),"€")), vjust = 1.4, color = "white") +
  scale_x_continuous(breaks = df$age, name = "Ancienneté des clients en mois") +
  scale_y_continuous(name = "Ventes brutes") +
  labs(title = "Evolution des ventes brutes") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(color = "gray", size = 0.1),
        panel.grid.minor.y = element_line(color = "gray", size = 0.1, linetype = "dashed"),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(hjust = 0.5))
```

Rétention en terme de ventes :
`r format(round(df$ca[df$age == 5]), scientific = F, big.mark = " ")` / `r format(round(df$ca[df$age == 0]), scientific = F, big.mark = " ")` = `r round(100*df$ca[df$age == 5]/df$ca[df$age == 0],1)` %

### Détection des départs

Lorsque la relation commerciale n'est pas contractuelle, il est difficile de savoir quand un client est parti ou bien si on va le voir revenir. Pour aller plus loin dans la Customer Lifetime Value (CLV), il faut que nous établissions une méthode de détection des départs clients.

Intuitivement on peut dire que ce phénomène dépend au moins de deux facteurs :<br>
- la durée depuis laquelle le client n'a pas passé de commande<br>
- le nombre de commandes du client, l'idée ici est que les clients régulier vont moins vite nous quitter que les clients occasionnels

Etudions ces facteurs pour tenter de trouver un moyen de savoir si un client peut encore être considéré comme actif ou non.

```{r, echo=FALSE, warning=FALSE}
# Echantillon de clients : première commande passée entre DEBUT et FIN
debut2 <- as.Date("2017-07-01")
# debut2 <- as.Date("2014-07-01")
fin2 <- as.Date("2018-03-31")
```

Dans cette partie il est moins important d'observer tous les clients pendant la même durée que dans la partie précédente. Tant que ces durées d'observation ne sont pas trop courtes elles n'ont pas à être égales.
Nous allons donc nous baser sur tous les clients qui ont passé leur première commande entre le `r debut2` et le `r fin2`, et nous les observerons jusqu'à aujourd'hui.

```{r, echo=FALSE, warning=FALSE}
comm <- commandes %>%
  filter(first_order_date >= debut2 & first_order_date <= fin2)
```

Cela nous donne un échantillon de `r n_distinct(comm$client_id)` clients qu'on a observé pendant une période de minimum 3 mois.

Répartition des délais (en jours) entre 2 commandes.

```{r echo=FALSE, warning=FALSE}
# Délai entre 2 commandes
q <- quantile(comm$delai[!comm$derniere], probs = seq(0,1,0.1), na.rm = T)
print(q)
```


```{r, echo=FALSE, warning=FALSE}
seuil <- 90
```


```{r echo=FALSE, warning=FALSE}
pct <- round(100 * sum(comm$delai[!comm$derniere] <= seuil)/sum(!comm$derniere), 1)

ggplot(mapping = aes(na.omit(comm$delai))) +
  stat_ecdf(geom = "step") +
  geom_vline(xintercept = seuil, color = "red", size = 0.5) +
  geom_text(aes(x = seuil, y = pct/100, label = paste(pct, "% des délais sont\ninférieurs à", seuil, "jours")), color = "red", hjust = -0.02, vjust = 1.1) +
  scale_y_continuous(breaks = seq(0,1,0.1)) +
  scale_x_continuous(breaks = seq(0, max(comm$delai, na.rm = T), 20)) +
  ggtitle("Courbe de répartition des délais entre 2 commandes") +
  xlab("X = Délai en jours") +
  ylab("Pourcentage de délais inférieurs à X") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  theme_bw()
```

```{r echo=FALSE, warning=FALSE}
# Fonction : crée un dataframe où une ligne est un délai entre 2 commandes successives d'un client (revenu = TRUE) ou entre sa derniere commande et aujourd'hui (revenu = FALSE)
func_df_delai<- function(com){
  df <- com %>%
    filter(!is.na(delai)) %>%
    select(delai, nieme, nieme_class) %>%
    mutate(revenu = T) %>%
    rename(duree = delai)
  temp <- com %>%
    filter(!is.na(pas_revu_depuis)) %>%
    select(pas_revu_depuis, nieme, nieme_class) %>%
    mutate(revenu = F) %>%
    rename(duree = pas_revu_depuis)
  df <- bind_rows(df, temp)
  return(df)
}

# fonction : Quand ça fait X jours que les clients n'ont pas commandé, combien sont revenus ?
revenu.apres <- function(df_delai,x){
  # nombre de retour après un délai > x
  nb_rev <- sum(df_delai$duree[df_delai$revenu] > x)
  nb_tot <- sum(df_delai$duree > x)
  return(round(nb_rev/nb_tot,3))
}

df <- func_df_delai(comm)

# Coordonnées du graph qui montre les chances de revoir un client selon le temps qu'on l'a pas vu
x <- 0:max(df$duree[df$revenu])
y <- sapply(x, revenu.apres, df = df)
coord <- data.frame(x = x, y = y)

# valeur associée au seuil défini
val <- coord$y[coord$x == seuil]

lab1 <- list(x = seuil,
             y = 0,
             text = paste(seuil, "jours"))

lab2 <- list(x = 0,
             y = val,
             text = paste(round(100*val,1), "%"))

lab3 <- list(x = seuil,
             y = val,
             text = paste("Après une absence de", seuil, "jours\nseuls", round(100*val,1), "% des clients finissent par revenir"))

ggplot() +
  geom_point(data = coord[coord$x >= 15,], aes(x = x, y = y), size = 0.7) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_text(mapping = aes(x = lab1$x, y = lab1$y, label = lab1$text), color = "red", vjust = -0.2, hjust = 1.05) +
  geom_text(mapping = aes(x = lab2$x, y = lab2$y, label = lab2$text), color = "red", vjust = 1.2, hjust = -0.05) +
  geom_text(mapping = aes(x = lab3$x, y = lab3$y, label = lab3$text), color = "red", vjust = -0.2, hjust = -0.01) +
  # segment vertical
  geom_segment(aes(x = seuil, xend = seuil, y = 0, yend = val), linetype = "dashed", colour = "red") +
  # segment horizontal
  geom_segment(aes(x = 0, xend = seuil, y = val, yend = val), linetype = "dashed", colour = "red") +
  scale_y_continuous(breaks = seq(0,1,0.05)) +
  scale_x_continuous(breaks = seq(0, max(comm$delai, na.rm = T), 20)) +
  ggtitle("Probabilité qu'un client passe une nouvelle commande\nselon la date de sa dernière commande") +
  xlab("Nombre de jours sans commande") +
  ylab("Pourcentage des clients qui ont passé une commande après X jours") +
  theme_bw()
```

Détaillons ces résultats en prenant en compte le nombre de commandes passées.

```{r, echo=FALSE, warning=FALSE}
df <- comm %>%
  filter(derniere) %>%
  group_by(nieme_class) %>%
  summarise(nb = n()) %>%
  ungroup()

ggplot(df) +
  geom_bar(stat = "identity", aes(x = nieme_class, y = nb, fill = nieme_class)) +
  geom_text(aes(x = nieme_class, y = nb, label = nb), color = "white", vjust = 1.4) +
  geom_hline(yintercept = 0) +
  scale_fill_manual(values = c(rouge, bleu, vert)) +
  theme_bw() +
  labs(title = "Nombre de clients dans chaque catégorie aujourd'hui",
       fill =  "Rang de la\ncommande\nprécédente",
       x = "Nombre de commandes actuel des clients",
       y = "Nombre de clients")
  
```

```{r, echo=FALSE, warning=FALSE}
df <- func_df_delai(comm)

coord <- data.frame()
for (i in levels(df$nieme_class)){
  y <- sapply(x, revenu.apres, df = df[df$nieme_class == i,])
  temp <- data.frame(x = x, y = y, nieme_class = i)
  coord <- bind_rows(coord, temp)
}
coord$nieme_class <- factor(coord$nieme_class, levels = levels(df$nieme_class))

# xmin <- 5
chances <- 0.3

ggplot(data = coord[x >= 10,]) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = chances, linetype = "dashed", size = 0.3, color = "red") +
  geom_line(aes(x = x, y = y, color = nieme_class), size = 0.5) +
  scale_color_manual(values = c(rouge, bleu, vert)) +
  scale_y_continuous(breaks = seq(0,1,0.1), labels =  paste(100*seq(0,1,0.1),"%")) +
  scale_x_continuous(breaks = seq(0, 180, 10),limits = c(10,180)) +
  theme_bw() +
  labs(color = "Rang de la\ncommande\nprécédente",
       title = "Probabilité de revoir un client qui n'a pas commandé depuis X jours\nselon son nombre de commandes passées",
       x = "X = Nombre de jours sans commande",
       y = "Probabilité que le client revienne")
```

Ce graphique se lit de la façon suivante :<br>
La courbe rouge représente les clients aprés leurs premières commandes. Elle montre quel pourcentage de clients sont revenus après avoir laissé passer X jours. On peut donc voir que parmi les clients qui n'ont pas repassé commande dans les 30 jours après leurs premières, seulement 30% ont finalement passé une seconde commande.<br>

Ce graphique montre bien que plus les clients sont fidèles, plus on peut laisser passer de temps avant de les considérer comme partis.<br>

```{r seuils, echo=FALSE}
seuil1 <- 30
seuil2 <- 50
seuil3 <- 70
```


On peut donc définir des seuils pour considérer que les clients sont partis selon le nombre de leur commandes. Au risque 20% cela donne les seuils suivants :<br>
`r seuil1` jours pour les clients n'ayant passé qu'une commande.<br>
`r seuil2` jours pour les clients ayant passé entre 2 et 5 commandes.<br>
`r seuil3` jours pour les clients ayant dépassé 5 commandes.<br>

```{r, echo=FALSE, warning=FALSE}
# ggplot(data = comm[!comm$derniere,], aes(x = delai)) +
#   stat_ecdf(geom = "step") +
#   geom_vline(data = ddply(comm[!comm$derniere,], "nieme_class", summarise, med = median(delai)), aes(xintercept = med), color = rouge) +
#   geom_text(data = ddply(comm[!comm$derniere,], "nieme_class", summarise, med = median(delai)), aes(x = med, y = 0, label = paste(round(med),"jours")), color = rouge, hjust = 0, vjust = 0) +
#   facet_grid(nieme_class ~ .) +
#   xlim(0,100) +
#   theme_bw() +
#   labs(title = "Répartition des délais entre les commandes",
#        subtitle = "Les délais entre les commandes sont plus courts au fil des commandes")

ggplot() +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_vline(xintercept = seuil1, color = rouge) +
  geom_vline(xintercept = seuil2, color = bleu) +
  geom_vline(xintercept = seuil3, color = vert) +
  stat_ecdf(data = comm[!comm$derniere,], aes(x = delai, color = nieme_class)) +
  scale_color_manual(values = c(rouge, bleu, vert)) +
  scale_x_continuous(breaks = seq(0,130,10), limits = c(0,130)) +
  scale_y_continuous(breaks = seq(0,1,0.1), labels = paste(100*seq(0,1,0.1),"%")) +
  theme_bw() +
  labs(color = "Rang de la\ncommande\nprécédente",
       title = "Répartition des délais entre les commandes",
       x = "X = Délai en jours avant la prochaine commande",
       y = "Pourcentage des commande passées\ndans un délai inférieures à X")
```

On voit bien que la grande majorité des commandes sont passées dans des délais inférieurs au seuils qu'on a définis :<br>
70% des secondes commandes sont passées moins de `r seuil1` jours après la première.<br>
90% des commandes n°3 à 6 sont passées moins de `r seuil2` jours après la précédente.<br>
Presque 100% des commandes n°7+ sont passées moins de `r seuil3` jours après la précédente.

Nous pouvons désormais nous servir de des seuils pour déterminer le statut (actif ou non) des clients et calculer leur durée de vie. Ce qui nous sera très utile dans la suite de ce document.

```{r creation du df clients, include=FALSE}
# cli <- comm %>%
#   select(client_id, first_order_date, order_created_at, gross_revenue, nieme, nieme_class) %>%
#   arrange(client_id, order_created_at) %>%
#   group_by(client_id) %>%
#   summarise(premiere = min(order_created_at),
#             derniere = max(order_created_at),
#             duree = as.numeric(difftime(derniere, premiere, units = "days")),
#             total = sum(gross_revenue),
#             nb_com = n(),
#             cat = last(nieme_class),
#             freq = nb_com/(as.numeric(duree)/30),
#             pas_vu_depuis = as.numeric(difftime(as.Date(now()), derniere, units = "days")),
#             actif = pas_vu_depuis <= ifelse(cat == "1ère", seuil1, ifelse(cat == "2-5ème", seuil2, seuil3)))
# 
# df <- cli %>%
#   filter(nb_com > 1 & !actif)

# moy <- mean(df$duree)
# n <- nrow(df)
# 
# df <- df %>%
#   mutate(x = row_number(),
#          y = dexp(x, rate = 1/moy))
# 
# ggplot(df, aes(x=duree)) +
#   geom_bar(aes(y = (..count..)/sum(..count..)), binwidth = 1) +
#   geom_line(aes(x = x, y = y))
```


### Classification des clients

```{r, echo=FALSE, warning=FALSE}
aujourdhui <- as.Date("2018-06-25")
```

Dans cette partie nous voulons étudier notre base clients actuelle, nous allons donc prendre en compte tous les clients et commandes depuis le 1er mai 2017, date de création de notre base de données.
Les données s'arrêtent au 25 juin 2018, le jour où cette étude à été réalisée.

```{r, include=FALSE}
# Nombre de mois pris en compte dans les calculs de la CLV limité à X mois
X <- 18 # X doit être pair

allcli <- commandes %>%
  # on renomme le orders_count original pour eviter les erreurs dans les calculs
  rename(count = orders_count) %>%
  filter(order_created_at <= aujourdhui) %>%
  arrange(client_id, order_created_at) %>% 
  group_by(client_id) %>%
  summarise(orders_count = n(),
            premiere = min(order_created_at),
            derniere = max(order_created_at),
            age_client = round(as.numeric(difftime(aujourdhui, premiere, units = "days"))),
            ddv = round(as.numeric(difftime(derniere, premiere, units = "days"))),
            panier_moyen = mean(gross_revenue),
            value = sum(gross_revenue),
            delai_moyen = mean(delai, na.rm = T),
            delai_moyen_alt = ddv/orders_count,
            pas_vu_depuis = round(as.numeric(difftime(aujourdhui, derniere, units= "days"))),
            cat = cut(orders_count, 
                           breaks = breaks_class_cli,
                           labels = labels_class_cli,
                           right = F,
                           include.lowest = T),
            # Le client est-il encore actif aujourd'hui
            actif = as.integer(pas_vu_depuis <= ifelse(cat == labels_class_cli[1], seuil1, ifelse(cat == labels_class_cli[2], seuil2, seuil3))),
            # NOMBRE de commande passé pendant les X PREMIERS mois
            orders_countXp = sum(age <= X),
            # NOMBRE de commande passé pendant les X DERNIERS mois 
            orders_countXd = sum(age_jour >= ddv - X*30),
            # NOMBRE de commande passé pendant les X/2 PREMIERS et DERNIERS mois 
            orders_countXmm = sum(age_jour >= ddv - X/2*30 | age <= X/2),
            # VALEUR du client pendant ses X PREMIERS mois
            valueXp = sum(gross_revenue[age <= X]),
            # VALEUR du client pendant ses X DERNIERS mois
            valueXd = sum(gross_revenue[age_jour >= ddv - X*30]),
            # VALEUR du client pendant ses X/2 PREMIERS et DERNIERS mois
            valueXmm = sum(gross_revenue[age_jour >= ddv - X/2*30 | age <= X/2]),
            # Le client est-il actif après X mois
            actifX = ifelse(actif & ddv < X*30, NA, !(!actif & ddv < X*30)))
```

#### Analyse en Composantes Principales

```{r, include=FALSE}
# L'ACP et la classification ont été faites avec SPAD
classif <- read.csv2(file = "/home/arnaud/Dropbox/Deligreens/classes.csv", sep = ",") %>%
  mutate(Identificateur = as.character(Identificateur),
         #client_id = as.integer(substring(Identificateur, 2, nchar(Identificateur)-1))) %>%
         client_id = substring(Identificateur, 2, nchar(Identificateur)-1)) %>%
  filter(!(Identificateur %in% c("1883", "2467"))) %>%
  rename(axe1 = Axe.1, axe2 = Axe.2) %>%
  select(client_id, axe1, axe2) %>%
  # Création des classes créées par SPAD
  mutate(classe = ifelse(axe1 < 0 & axe2 > -2.5, "Classe 1",
                         ifelse(axe1 > 0 & axe2 > -1.9, "Classe 3",
                                ifelse(axe1 > 2 & axe2 < -1.9, "Classe 4", "Classe 2"))))

allcli <- classif %>%
  select(client_id, classe) %>%
  left_join(allcli, ., by = "client_id")

# Correction d'une erreur introduite par la différence entre les arrondis lors de la détermination du statut actif ou non des clients
correction <- c(1948,2018,2070,2136,2143,2635,2767,2874,2882,3020,3378)
allcli <- allcli %>%
  mutate(actif = ifelse(client_id %in% correction, 0, actif))

col1 <- "red"
col2 <- "orange"
col3 <- "deepskyblue1"
col4 <- "blue"
```

L'analye en composantes principales est un méthode d'analyse de données multidimensionnelle qui consiste à réduire le nombre de dimension de façon à rendre les données visualisables tout en ne perdant qu'un minimum d'informations. Ici, nous étudions nos `r nrow(allcli)` clients selon les dimensions suivantes :<br>
Son age (le nombre de jour entre aujourd'hui et sa première commande)<br>
Sa durée de vie (le nombre de jours entre sa première et sa dernière commande en date)<br>
Son état actuel (client actif ou non)<br>
Son nombre de commandes<br>
Son panier moyen<br>
Son absence (le nombre de jours entre aujourd'hui et sa dernière commande en date)<br>

L'ACP nous permet de resumer au mieux ces 6 dimensions en 2 et de représenter les clients ainsi.

```{r, echo=FALSE, warning=FALSE}
ggplot() +
  geom_point(data = classif, aes(x = axe1, y = axe2)) +
  theme_bw()
```

Chaque point représente un client, et les 2 axes sont les "composantes principales", les 2 dimensions artificielles qui résument au mieux les 6 réelles.<br>
On peut voir que les clients se découpent en plusieurs ensembles.<br>
Utilisons une méthode de classification pour creuser la question.

#### Classification

```{r classif, echo=FALSE, warning=FALSE}
ggplot() +
  geom_point(data = classif, aes(x = axe1, y = axe2, color = classe)) +
  theme_bw() +
  scale_color_manual(values = c(col1, col2, col3, col4)) +
  labs(#title = "Classification des clients",
       color = NULL)
```

La classification aboutit à 4 classes (ou cohortes) différentes. Ce sont des groupes de clients qui ont des résultats similaires sur les 6 dimensions étudiées. Regardons maintenant en quoi ces cohortes se différencient pour mettre du sens sur cette classification.

```{r, echo=FALSE, warning=FALSE}

res <- allcli %>%
  filter(!is.na(classe)) %>%
  group_by(classe) %>%
  summarise(nb_cli = n(),
            actif = paste(round(100*sum(actif)/n()),"%"),
            nb_com = round(mean(orders_count),1),
            ddv = round(mean(ddv)),
            absence = round(mean(pas_vu_depuis)),
            age = round(mean(age_client)),
            # delai = round(mean(delai_moyen, na.rm = T),1),
            panier = round(mean(panier_moyen),1))

colonnes <- c("Classe", "Nombre de clients", "Clients actifs", "Nombre de commandes moyen", "Durée de vie moyen (jours)", "Absence moyenne (jours)", "Age moyen (jours)", "Panier moyen (€)")
kable(res, col.names = colonnes)
```

Voici les moyennes des différentes classes pour chacune des 6 dimensions.<br>
On peut résumer les classes ainsi :<br>

La première classe correspond aux clients qui ne sont plus actifs et qui ne l'ont jamais vraiment été. Ils ont passé peu de commandes et sont absents depuis longtemps.<br>
La seconde classe est la classe des anciens bons clients. Ils ont des bons nombres de commandes et de bonnes durées de vie mais ils ne sont malheuresement plus actifs : absents depuis longtemps.<br>
La troisième classe est celle des nouveaux. Ils ne sont pas là depuis longtemps et n'ont pas encore passé beaucoup de commandes mais ils sont encore actifs et nombreux, ce qui est prometteur pour la suite.<br>
La quatrième classe est celle des meilleurs. Les clients qui nous suivent depuis longtemps, qui ont déjà beaucoup commandé et qui sont toujours actifs.

```{r CLV par classe, echo=FALSE, warning=FALSE}
res <- res %>%
  mutate(value_moy = nb_com * panier)


ggplot(res) +
  geom_bar(aes(x = classe, y = value_moy, fill = classe), stat ="identity") +
  scale_fill_manual(values = c(col1, col2, col3, col4)) +
  geom_text(aes(x = classe, y = value_moy, label = paste(round(value_moy),"€")), color = "white", vjust = 1.3) +
  geom_hline(yintercept = 0) +
  labs(title = "Customer Value historique moyenne",
       y = "Customer Value moyenne (en €)") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(color = "gray", size = 0.1),
        panel.grid.minor.y = element_line(color = "gray", size = 0.1, linetype = "dashed"),
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.title.x = element_blank(),
        legend.position = "none")
```

Sans surprise on constate que la valeur des clients de la classe 4 est nettement supérieure aux autres. Il est important de noter aussi que ce graphique montre la valeur actuelle (ou historique) des clients. C'est à dire qu'il ne compte que les transactions passées des clients, les valeurs des clients des classes actives (3 et 4) vont donc augmenter au fur et à mesure de leurs futures commandes.

### Fréquence d'achat

Calculée sur tous les clients qui ont passé plus d'une commande.

```{r revenu des classes, include=FALSE}
df <- allcli %>%
  filter(orders_count > 2 & delai_moyen_alt != 0)

N <- nrow(df)

df <- df %>%
  mutate(classe_freq = cut(delai_moyen_alt, include.lowest = T,
                           breaks = c(0,15,30,60,150,Inf),
                           labels = c("0-15 jours", "16-30 jours", "31-60 jours", "61-150 jours", "Plus de 150 jours"))) %>%
  group_by(classe_freq) %>%
  summarise(y = n()) %>%
  ungroup() %>%
  mutate(pct = y/N,
         cum = cumsum(y),
         mid = cum - y/1.2)


# ggplot(data = df) +
#   geom_bar(stat = "identity", aes(x = "", y = y, fill = classe_freq), width = 1) +
#   geom_text(aes(x = "", y = mid, label = paste(round(100*pct,1),"%"))) +
#   coord_polar("y") +
#   theme_classic() +
#   labs(fill = "Fréquence moyenne") +
#   theme(axis.text = element_blank(),
#         axis.title = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank())
```

```{r frequences achat, echo=FALSE, warning=FALSE}
ggplot(data = df) +
  geom_bar(stat = "identity", aes(x = classe_freq, y = pct, fill = classe_freq), width = 1) +
  geom_text(aes(x = classe_freq, y = pct, label = paste(round(100*pct,1),"%")), vjust = -0.3) +
  geom_hline(yintercept = 0) +
  theme_classic() +
  labs(title = "Distribution des fréquences d'achat des clients",
       x = "Fréquence d'achat moyenne du client") +
  scale_fill_brewer(palette = "Greens", direction = -1) +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5))
```

### Panier moyen

Calculée sur tous les clients.

```{r paniers moyens, echo=FALSE, warning=FALSE}
N <- nrow(allcli)

df <- allcli %>%
  mutate(classe_panier = cut(panier_moyen,
                             breaks = c(seq(0,160,20),Inf))) %>%
  group_by(classe_panier) %>%
  summarise(nb = n(),
            pct = nb/N)

ggplot(df) +
  geom_bar(aes(x = classe_panier, y = pct, fill = classe_panier), stat = "identity", width = 1) +
  geom_text(aes(x = classe_panier, y = pct, label = paste(round(pct*100,1),"%")), vjust = -0.3) +
  geom_hline(yintercept = 0) +
  scale_fill_brewer(palette = "Greens") +
  theme_classic() +
  labs(title = "Distribution des paniers moyens des clients",
       x = "Panier moyen (€)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5))
```

On peut aussi observer les paniers moyens de la façon suivante.

```{r repartition panier moyen, echo=FALSE, warning=FALSE}
q <- quantile(allcli$panier_moyen)[2:4]

ggplot(mapping = aes(allcli$panier_moyen)) +
  stat_ecdf(geom = "step") +
  scale_y_continuous(breaks = seq(0,1,0.1), labels = paste(100*seq(0,1,0.1),"%")) +
  scale_x_continuous(breaks = seq(0, 300, 20)) +
  # 1er quartile : segment vertical
  geom_segment(aes(x = q[1], xend = q[1], y = 0, yend = 0.25), linetype = "dashed", colour = rouge) +
  # 1er quartile  : segment horizontal
  geom_segment(aes(x = 0, xend = q[1], y = 0.25, yend = 0.25), linetype = "dashed", colour = rouge) +
  # 1er quartile  : texte
  geom_text(aes(x = q[1], y = 0.25, label = paste("25% =", round(q[1]),"€")), color = rouge, hjust = 1.05, vjust = -0.3) +
  # mediane : segment vertical
  geom_segment(aes(x = q[2], xend = q[2], y = 0, yend = 0.5), linetype = "dashed", colour = rouge) +
  # mediane : segment horizontal
  geom_segment(aes(x = 0, xend = q[2], y = 0.5, yend = 0.5), linetype = "dashed", colour = rouge) +
  # mediane : texte
  geom_text(aes(x = q[2], y = 0.5, label = paste("Médiane =", round(q[2]),"€")), color = rouge, hjust = 1.05, vjust = -0.3) +
  # 3ème quartile  : segment vertical
  geom_segment(aes(x = q[3], xend = q[3], y = 0, yend = 0.75), linetype = "dashed", colour = rouge) +
  # 3ème quartile : segment horizontal
  geom_segment(aes(x = 0, xend = q[3], y = 0.75, yend = 0.75), linetype = "dashed", colour = rouge) +
  # 3ème quartile : texte
  geom_text(aes(x = q[3], y = 0.75, label = paste("75% =", round(q[3]),"€")), color = rouge, hjust = 1.05, vjust = -0.3) +
  ggtitle("Courbe de répartition des paniers moyens") +
  xlab("X = Panier moyen (en €)") +
  ylab("Pourcentage des paniers moyens inférieurs à X") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0,260))
```

### Customer Lifetime Value prédictive

Pour prédire la valeur totale d'un nouveau client, nous allons d'abord essayer de prédire le nombre de commandes total qu'il va passer. 

Grâce à nos données historiques nous allons calculer la probabilité qu'un client parte après sa Xème commande (et donc sans passer une X+1ème commande).
Pour cela nous utilisons les mêmes données que précédemment : tous les clients et commandes depuis le 1er mai 2017. <br>
Ce qui représente un ensemble de `r nrow(allcli)` clients. Mais tous ne vont pas être pris en compte.

```{r df cli, echo=FALSE}
seuil_com <- 20
lib_com <- paste0(seuil_com,"-Inf")
breaks <- c(1:6,9,seuil_com, Inf)
# breaks <- c(1:seuil_com,Inf)

# Création des labels
labels <- NA
for (i in 2:length(breaks)){
  if(breaks[i] - breaks[i-1] == 1){
    labels[i-1] <- as.character(breaks[i-1])
  }else{
    labels[i-1] <- paste0(breaks[i-1], "-", breaks[i]-1)
  }
}

cli <- allcli %>%
  filter(derniere >= as.Date("2017-03-01")) %>% # "2017-05-01" : Pour revoir les resultats de la première version de cette étude
  mutate(classe_count = cut(orders_count,
                            breaks = breaks,
                            labels = labels,
                            include.lowest = T, right = F))

t <- table(cli$classe_count,cli$actif)
colnames(t) <- c("Non actif", "Actif")
t
```

Dans ce tableau on voit le nombre de clients actifs et non actifs selon leur nombre de commandes.
`r t[1,1]` clients sont donc partis en ayant passé qu'une seule commande et `r t[nrow(t),2]` sont encore actifs après au moins `r seuil_com` commandes.

Pour étudier les départs des clients nous allons nous intéresser essentiellement à la colonne de gauche, celle des clients qui sont partis.

Le groupe des clients partis après avoir passé au moins `r seuil_com` commandes est trop hétérogène pour pouvoir être étudié de la même façon que les autres alors nous allons traiter ce cas à part. Nous allons donc découper l'univers des possibilités ainsi : <br>
Soit le client nous quitte avant sa `r seuil_com`ème commande ; soit le client atteint le seuil de `r seuil_com` commandes.

On a donc un échantillon composé ainsi :

```{r,echo=FALSE}
text <- paste("Nombre de clients partis après leurs commandes n°", rownames(t[-nrow(t),]), ": ")
text <- c(text, paste("Nombre de clients ayant atteint", seuil_com, "commandes : "))
val <- t[,1]
val[nrow(t)] <- val[nrow(t)] + t[nrow(t),2]

ech <- data.frame(a = text, b = val)
rownames(ech) <- NULL

kable(ech, col.names = c("",""))
```

<br>
Nous allons calculer la probabilité qu'un client appartienne à chacune de ces catégories.

```{r, echo=FALSE}
N <- sum(t[,1], last(t[,2]))
```

<br>
Nous avons `r N` clients qui entrent dans ce découpage des possibilités, les autres ne sont pas partis et n'ont pas atteint le seuil de `r seuil_com` commandes : donc leur "vie" avec Deligreens n'est pas finie et n'est pas assez longue alors ils ne vont pas être pris en compte dans cette estimation.

Une simple division nous permet alors d'obtenir les probabilités suivantes :

```{r proba, echo=FALSE}
res <- cli %>%
  filter(!(actif & orders_count < seuil_com)) %>%
  group_by(classe_count) %>%
  summarise(probs = n()/N,
            probs2 = paste(round(100*probs,1),"%"),
            value_moy = round(mean(value),2),
            value_moyXprem = round(mean(valueXp),2),
            value_moyXmm = round(mean(valueXmm),2),
            value_moyXder = round(mean(valueXd),2)) %>%
  ungroup() %>%
  mutate(value_moy = ifelse(classe_count == lib_com, NA, value_moy),
         classe_count = as.character(classe_count))

res <- rbind(res, c(NA, 1.0, NA, NA, round(sum(res$probs * res$value_moyXprem),2), round(sum(res$probs * res$value_moyXmm),2), round(sum(res$probs * res$value_moyXder),2))) %>%
  mutate(classe_count = as.character(classe_count))
res[nrow(res),1] <- "Moyenne"
res[nrow(res),3] <- "100 %"

text <- paste("Probabilité qu'un client nous quitte après sa commande n°", rownames(t[-nrow(t),]), ": ")
text <- c(text, paste("Probabilité qu'un client passe au moins", substr(last(rownames(t)),1,2), "commandes : "))

affich <- data.frame(a = text, b = res$probs2[-nrow(res)])

kable(affich, col.names = c("",""))
```

<br>
Pour calculer la valeur moyenne d'un client de toutes ces catégories sauf la dernière c'est simple : il nous suffit de prendre la moyenne des valeurs des clients qui les composent.

```{r, echo=FALSE}
kable(subset(res, select = -probs), col.names = c("", "proba", "value totale", paste("value",X,"premiers mois"), paste("value",X/2,"premiers",X/2,"derniers mois"), paste("value",X,"derniers mois")))
```

Pour compléter les cases manquantes dans  on va changer de méthode, ces clients étant encore actifs pour la grande part, on ne connait pas leur valeur effective.

Calculons maintenant la probabilité qu'une commande d'un client ayant atteint `r seuil_com` commandes soit sa dernière. Pour cela on compte toutes les commandes qu'on passé les clients après ce seuil et on regarde parmi ces commandes combien ont été des dernières commandes.

```{r,echo=FALSE}
nb_com <- cli %>%
  filter(classe_count == lib_com) %>%
  mutate(nb_com_ap_seuil = orders_count - seuil_com + 1) %>%
  summarise(nb = sum(nb_com_ap_seuil)) %>%
  as.integer()

nb_depart <- t[nrow(t),1]

p <- nb_depart/nb_com
```

Les `r last(val)` clients de la catégorie `r last(names(val))` ont passé un total de `r nb_com` commandes après avoir atteint le seuil de `r seuil_com` commandes. Parmi ces commandes, `r nb_depart` ont été des dernières commandes, qui marquent donc le départ d'un client. En divisant le second par le premier on trouve une probabilité de `r round(100*p,1)` % qu'un clients de cette catégorie nous quitte après chaque commande.

Grâce à cette information on peut estimer à `r round(1/p) + seuil_com - 1` le nombre moyen de commandes que vont passer ces clients avant de nous quitter.

```{r,echo=FALSE}
panier <- cli %>%
  filter(classe_count == lib_com) %>%
  summarise(moy = mean(panier_moyen, na.rm = T)) %>%
  as.numeric()
value <- panier/p
```

Et grâce au panier moyen des clients de cette catégorie on peut déduire leur CLV moyenne et enfin calculer une estimation de la Customer LifeTime Value totale.

```{r, echo=FALSE}
res$value_moy[nrow(res)-1] <- value

clv <- round(sum(res$probs[-nrow(res)]*res$value_moy[-nrow(res)]),2)
res$value_moy[nrow(res)] <- clv

kable(subset(res,select=-probs), col.names = c("", "proba", "value totale", paste("value",X,"premiers mois"), paste("value",X/2,"premiers",X/2,"derniers mois"), paste("value",X,"derniers mois")))
```

Enfin, en calculant une moyenne pondérée on trouve une Customer Lifetime Value totale de `r round(clv,2)` €

### CLV : seconde méthode

On va regrouper les clients en fonction de leur mois d'arrivée. Parmi les cohortes formées on va ne garder que celles qui correspondent aux clients arrivés depuis le dernier changement majeur de l'offre de Deligreens : la suppression de l'abonnement en février. On exclut aussi les cohortes qui comptent moins de 20 clients et celles pour lesquelles on a moins de 4 mois complets de données.

Pour chaque cohorte restante on va utiliser les données existantes pour créer un modèle qui nous permettra de prédire le gross revenue futur.
```{r, echo=FALSE, warning=FALSE, fig.width=11,fig.height=7}
debut3 <-as.Date("2017-03-01")

# Calcul des agrégat par mois et par cohorte
df_cohorte <- commandes %>%
  filter(first_order_date >= debut3) %>%
  # on enlève les commandes du mois en cours pour chaque client (si un client est là depuis 1,2 mois on se limite à 1 mois de données)
  mutate(age_actuel = as.numeric(difftime(today(), first_order_date, units = "days"))/30) %>%
  # group_by(client_id) %>%
  filter(age < floor(age_actuel)) %>%
  # ungroup() %>%
  group_by(cohorte, age) %>%
  summarise(nb_client = n_distinct(client_id),
            nb_com = n(),
            gross_revenue = sum(gross_revenue)) %>%
  ungroup() %>%
  group_by(cohorte) %>%
  # On veut au moins 20 clients dans la cohorte et 4 mois complets de données
  filter(max(nb_client) >= 20 & n() >= 4) %>%
  mutate(pct_revenue = gross_revenue/first(gross_revenue),
         cum_revenue = cumsum(gross_revenue)) %>%
  ungroup() %>%
  droplevels()

levels <- levels(df_cohorte$cohorte)

# Pour chaque cohorte on trouve un modèle, et on calcule les prédictions de ce modèle pour x mois
mois_max <- max(c(18,X))
pred <- NULL
for(c in levels){
  df <- df_cohorte %>%
    filter(cohorte == c)
  mod <- lm(log(gross_revenue) ~ age, df)
  b <- mod$coefficients[1]
  a <- mod$coefficients[2]
  res <- data.frame(cohorte = factor(c, levels = levels),
                     age = 0:mois_max,
                     prediction = exp(a*(0:mois_max)+b)) %>%
    mutate(cum_prediction = cumsum(prediction))
  pred <- rbind(pred, res)
}

# On rajoute les prédictions dans de df_cohorte
df_cohorte <- left_join(pred, df_cohorte, by = c("cohorte", "age"))

# # Evolution du gross_revenue par mois par cohorte
# df <- dcast(df_cohorte, cohorte ~ age, value.var = "gross_revenue")
# 
# # Quand les clients d'une cohorte n'ont pas commandé un mois donné ça a introduit des NA qu'on remplace par des 0
# for(i in 1:nrow(df)){
#   for(j in 2:nrow(df)){
#     if(i+j <= nrow(df)+2 & is.na(df[i,j])){
#       df[i,j] <- 0
#     }
#   }
# }
# # On renomme les colonnes : le premier mois devient "1" et plus "0"
# colnames(df) <- c(colnames(df)[-2], as.character(nrow(df)))

# mois_ltv <- X

ggplot(df_cohorte, aes(x = age + 1)) +
  geom_line(aes(y = prediction), color = "red") +
  geom_point(aes(y = gross_revenue)) +
  geom_vline(xintercept = X, linetype = "dashed") +
  # geom_smooth(data = df_cohorte, method = "lm", formula = (log(gross_revenue)~age), size = 0.5, color = "red", se = F) +
  # geom_text(aes(x = X, y = 5000, label = paste(X,"mois")), hjust = -0.1, size = 3) +
  theme_bw() +
  scale_x_continuous(breaks = seq(0,mois_max,2)) +
  # ylim(c(0,15000)) +
  # coord_cartesian(ylim=c(0, 15000)) +
  labs(title = "Evolution du gross revenue des cohortes par mois glissants",
       x = "Mois",
       y = "Gross Revenue en €") +
  facet_wrap( ~ cohorte,
              scales = "free_y",
              ncol = 3)

# ggplot(df_cohorte, aes(x = age + 1, y = pct_revenue, color = cohorte)) +
#   geom_line() +
#   geom_point() +
#   theme_bw()
```
<br>
Grâce aux modèles ci-dessus, nous aboutissons aux résultats suivants.

```{r, echo=FALSE}
# Pour virer l'affichage en notation scientifique
options(scipen = 999)

df <- df_cohorte %>%
  group_by(cohorte) %>%
  summarise(value_cohorte = round(cum_prediction[age == X],2),
            nb_client = nb_client[age == 0]) %>%
  ungroup() %>%
  mutate(value_client = round(value_cohorte/nb_client,2))
df
# Pour remettre le réglage par défaut
options(scipen = 0)
```

```{r, echo=FALSE}
ltv <- sum(df$value_cohorte)/sum(df$nb_client)
```
<br>
Ce qui donne une CLV moyenne à `r X` mois de `r round(ltv,2)` €.

## Analyse de survie

```{r,echo=FALSE}
dfs <- cli
dfs$surv_ddv <- Surv(round(dfs$ddv/30,1), !dfs$actif)

km_ddv <- survfit(dfs$surv_ddv~1)

# Fonction qui donne la proba d'être en vie après X mois
survest <- stepfun(km_ddv$time, c(1, km_ddv$surv))

probaX <- round(100*survest(X),1)

ggsurvplot(km_ddv,
           data = dfs,
           censor = F,
           xlab = "Mois",
           ylab = "Chances de survie",
           break.x.by = 2,
           break.y.by = 0.1,
           ggtheme = theme_bw(),
           risk.table = T,
           fontsize = 3.8,
           legend = "none",
           title = "Courbe de survie")
```
<br>
Les clients ont `r probaX` % de chances d'être toujours actifs au bout de `r X` mois.